## Общие правила
- Всегда отвечай на русском языке
- При сомнениях в коде оставляй комментарий `TODO <причина сомнений>`
- Выполняй только то, что просят в задаче, ничего лишнего
- Если видишь проблему в legacy коде - напиши `TODO` комментарий, не исправляй сам
- В документации методов в конце предложения ставь точку
- В документации используй повелительное наклонение: "Получить сертификат по ИД.", а не "Получает сертификат по ИД."
- Приватные поля именуй без подчеркивания `_`

## Правила для прикладной разработки Directum RX

### Синтаксис и стиль кода

- Используй `var` для объявления переменных вместо явного указания типа (например, `var isNameEmpty = true;` вместо `bool isNameEmpty = true;`)
- Вызовы нестатических методов всегда начинай с `this`
- Не используй модификатор `virtual` без необходимости — это нарушает совместимость при рефакторинге. По умолчанию используй `private`, если позволяет архитектура
- В параметрах методов передавай интерфейсы вместо конкретных сущностей
- Группируй параметры в структуры, если их больше 3 или они представляют логическую модель данных
- Методы и свойства именуй в стиле PascalCase (например, `GetDocumentResponsibleEmployee`)
  
### Работа с ресурсами и локализация

- Все текстовые строки которые увидит пользователь храни только в ресурсах
- Локализация поддерживается на двух языках: `*.resx` — для английского, `*.ru.resx` — для русского
- В английских ресурсах создавай запись со значением `TODO` (без кавычек)
- Для добавления ресурса необходимо добавить его в файлы ресурсов и в метаданные модуля или типа сущности, которому принадлежит ресурс в поле "ResourcesKeys"

### Архитектура и слои приложения

- Код разделяй на слои: **Shared** (общая функциональность), **Client** (логика интерфейса), **Server** (серверная логика), **Isolated** (изолированный код)
- Вся бизнес-логика и работа с сущностями выполняется только в **серверном коде**
- В **клиентских функциях** размещай только UI-логику: видимость, доступность, валидация, автозаполнение свойств..
- Клиентские функции `Refresh` или `bool Can...` не должны вызывать серверные функции, особенно с обращением к сущностям — это создает избыточную нагрузку на сервер

## Атрибуты и доступность

- Для вызова серверной функции из клиента используй атрибут `[Remote]`
- Если функция не изменяет состояние сущности, используй `[Remote(IsPure = true)]`
- Для вызова функции из другого модуля используй атрибут `[Public]`. Пример: `Docflow.PublicFunctions.OfficialDocument.GetSuitableDocuments(documents, action);`
- Константы с атрибутом `[Public]` вызывай через `PublicConstants`. Пример: `Sungero.Parties.PublicConstants.Module.LegalEntityTinLength`
- Для устаревшего кода используй атрибут `[Obsolete]` с указанием новой версии метода или модуля вместо удаления

### Работа с сущностями

- Получение сущности выполняй через репозиторий. Пример: `var employee = Sungero.Company.Employees.GetAll(e => e.Person.FirstName == "Василий").FirstOrDefault();`
- Репозиторий (например, `Employees`) используй для создания, получения и удаления сущностей
- В экземплярных функциях `_obj` — это текущий экземпляр класса

### Константы и конфигурация

- Храни константы в специальных классах: `ModuleConstants.cs` — для констант модуля, `OfficialDocumentConstants.cs` — для констант сущности

### LINQ и коллекции

- Используй цепочки методов LINQ: `.Where().Select().ToList()`
- Для проверки наличия элементов используй `Any()` вместо `Count() > 0`
- Для проверки пустых коллекций используй `!collection.Any()` вместо `collection.Count() == 0`

## Работа со строками

- Для большинства случаев используй `IsNullOrWhiteSpace` вместо `IsNullOrEmpty`

## Обработка ошибок

- Обрабатывай ошибки явно с использованием логирования через `Logger`

### Организация кода

- Разделяй функциональность на блоки с помощью регионов (`#region` / `#endregion`)
- Группируй методы логически по сущностям и функциональности
- Все классы имеют пространство имен `Sungero.*` (например, `Sungero.Docflow`, `Sungero.RecordManagement`)
- Каждый метод снабжай понятной документацией

### Расширяемость

- Для расширяемой функциональности используй виртуальные методы с ключевым словом `virtual`
- Для переопределения используй `override`
- Базовый функционал размещай в базовых классах с поддержкой расширения через переопределение

### Ограничения

- **Не создавай** новые классы вручную! — это сделает разработчик через специальную программу DDS, которая генерирует дополнительный код
- **Не редактируй** файлы `*.mtd` — они автогенерируются через DDS
- **Не редактируй** файлы `*.g.cs` — они автогенерируются через DDS
- Свои файлы в прикладном решении создавать нельзя!
- Не используй Expression и все что с ним связано, вместо него используй lambda функции или делегаты

### Особенности платформы Sungero

- LINQ запросы GetAll() репозитория, транслируются в SQL. С осторожностью используй конструкции .Contains(). Функция транслируется в SQL как in (:id1, :id2, id3..) кол-во id ограниченно для int, long, guid - 64000. Для string - 2100.
- Если есть перечисление с generic-типом, отличающимся от int, long, Guid, то приведение этого перечисления через .ToList() не поможет обойти ограничение количества параметров для MSSQL в запросе с Contains(). Например: {Репозиторий типа сущности}.GetAll(x => enumerable.ToList().Contains(x.{свойство с типом, отличным от int, long, Guid})) всё равно упадёт с ошибкой System.Data.SqlClient.SqlException
- Нельзя добавлять атрибут [Public] для generic-методов — платформа такое не поддерживает и не сгенерирует для них метаданные, из-за чего эти методы не получится использовать в других модулях
